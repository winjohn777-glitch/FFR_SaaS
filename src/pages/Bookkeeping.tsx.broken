import React, { useState, useEffect } from 'react';
import styled from 'styled-components';
import { motion } from 'framer-motion';
import {
  BookOpen,
  Plus,
  Search,
  Filter,
  FileText,
  DollarSign,
  CheckCircle,
  AlertCircle,
  Scale,
  Edit,
  Save,
  X,
  Download,
  BarChart3,
  ChevronDown,
  ChevronRight
} from 'lucide-react';
import { useData } from '../contexts/DataContext';
import chartOfAccountsData from '../data/chartOfAccounts.json';
import BrandedModalTitle from '../components/Shared/BrandedModalTitle';

// Types for accounting data
interface Account {
  id: number;
  account_code: string;
  account_name: string;
  account_type: string;
  subcategory?: string;
  balance?: number;
}

interface Transaction {
  id: number;
  transaction_date: string;
  description: string;
  reference: string;
  total_amount: number;
  transaction_type: string;
}


interface JournalEntry {
  date: string;
  description: string;
  reference: string;
  lines: {
    account_id: number;
    debit_amount: number;
    credit_amount: number;
    description: string;
  }[];
}

// Styled Components
const BookkeepingContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.xl};
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.lg};
  flex-wrap: wrap;
`;

const HeaderActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  flex-wrap: wrap;
`;

const Title = styled.h1`
  font-size: 2rem;
  font-weight: 700;
  color: ${({ theme }) => theme.colors.text.primary};
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
`;

const TabContainer = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Tab = styled.button<{ active: boolean }>`
  padding: ${({ theme }) => theme.spacing.md} ${({ theme }) => theme.spacing.lg};
  border: none;
  background: ${({ active, theme }) => active ? theme.colors.primary : 'transparent'};
  color: ${({ active, theme }) => active ? 'white' : theme.colors.text.secondary};
  border-radius: ${({ theme }) => theme.borderRadius.md} ${({ theme }) => theme.borderRadius.md} 0 0;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};

  &:hover {
    background: ${({ active, theme }) => active ? theme.colors.primary : theme.colors.background};
  }
`;

const ContentArea = styled.div`
  background: ${({ theme }) => theme.colors.surface};
  border-radius: ${({ theme }) => theme.borderRadius.lg};
  padding: ${({ theme }) => theme.spacing.xl};
  box-shadow: ${({ theme }) => theme.shadows.sm};
  border: 1px solid ${({ theme }) => theme.colors.border};
`;

const ActionBar = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  gap: ${({ theme }) => theme.spacing.md};
  flex-wrap: wrap;
`;

const ActionButton = styled.button<{ variant?: 'primary' | 'secondary' }>`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  padding: ${({ theme }) => theme.spacing.md} ${({ theme }) => theme.spacing.lg};
  border: none;
  border-radius: ${({ theme }) => theme.borderRadius.md};
  background: ${({ variant, theme }) =>
    variant === 'primary' ? theme.colors.primary : theme.colors.surface};
  color: ${({ variant, theme }) =>
    variant === 'primary' ? 'white' : theme.colors.text.primary};
  border: 1px solid ${({ variant, theme }) =>
    variant === 'primary' ? theme.colors.primary : theme.colors.border};
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    transform: translateY(-1px);
    box-shadow: ${({ theme }) => theme.shadows.md};
  }
`;

const SearchContainer = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  flex: 1;
  max-width: 400px;
`;

const SearchInput = styled.input`
  flex: 1;
  padding: ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.md};
  font-size: 0.875rem;

  &:focus {
    outline: none;
    border-color: ${({ theme }) => theme.colors.primary};
  }
`;

const TransactionTable = styled.table`
  width: 100%;
  border-collapse: collapse;
  margin-top: ${({ theme }) => theme.spacing.lg};
`;

const TableHeader = styled.th`
  padding: ${({ theme }) => theme.spacing.md};
  text-align: left;
  font-weight: 600;
  color: ${({ theme }) => theme.colors.text.secondary};
  border-bottom: 2px solid ${({ theme }) => theme.colors.border};
`;

const TableRow = styled.tr`
  &:hover {
    background: ${({ theme }) => theme.colors.background};
  }
`;

const TableCell = styled.td`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text.primary};
  overflow: visible;
`;

const CategoryHeaderRow = styled.tr<{ expanded: boolean }>`
  background-color: ${({ theme }) => theme.colors.background};
  cursor: pointer;
  transition: background-color 0.2s ease;

  &:hover {
    background-color: ${({ theme }) => theme.colors.border};
  }
`;

const CategoryHeaderCell = styled.td`
  padding: ${({ theme }) => theme.spacing.lg};
  font-weight: 700;
  color: ${({ theme }) => theme.colors.text.primary};
  font-size: 1.1rem;
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
`;

const CategoryIcon = styled.div`
  color: ${({ theme }) => theme.colors.text.secondary};
  display: flex;
  align-items: center;
`;

const Modal = styled(motion.div)`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.lg};
`;

const ModalContent = styled(motion.div)`
  background: ${({ theme }) => theme.colors.surface};
  border-radius: ${({ theme }) => theme.borderRadius.lg};
  padding: ${({ theme }) => theme.spacing.xl};
  width: 100%;
  max-width: 1000px;
  max-height: 98vh;
  overflow-y: auto;
  overflow-x: visible;
  box-shadow: ${({ theme }) => theme.shadows.xl};
  margin: ${({ theme }) => theme.spacing.sm};

  /* Allow select dropdowns to escape modal bounds */
  & select {
    overflow: visible !important;
  }
`;

const ModalHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  padding-bottom: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
`;

const ModalTitle = styled.h2`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  font-size: 1.5rem;
  font-weight: 700;
  color: ${({ theme }) => theme.colors.text.primary};

  img {
    height: 24px;
    width: 24px;
    flex-shrink: 0;
  }
`;

const FormGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const FormGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.sm};
`;

const Label = styled.label`
  font-weight: 600;
  color: ${({ theme }) => theme.colors.text.primary};
  font-size: 0.875rem;
`;

const Input = styled.input`
  padding: ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.md};
  font-size: 0.875rem;

  &:focus {
    outline: none;
    border-color: ${({ theme }) => theme.colors.primary};
  }
`;

const Select = styled.select`
  padding: ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.md};
  font-size: 0.875rem;
  background: white;
  width: 100%;
  position: relative;
  z-index: 1;

  &:focus {
    outline: none;
    border-color: ${({ theme }) => theme.colors.primary};
    z-index: 2;
  }

  /* Style optgroup labels for better visibility */
  optgroup {
    font-weight: bold;
    font-style: normal;
    color: ${({ theme }) => theme.colors.primary};
    background-color: #f0f4f8;
    padding: 4px 0;
  }

  /* Style options within optgroups */
  optgroup option {
    font-weight: normal;
    color: ${({ theme }) => theme.colors.text.primary};
    background-color: white;
    padding-left: 8px;
  }
`;

const JournalEntryTable = styled.table`
  width: 100%;
  border-collapse: collapse;
  margin: ${({ theme }) => theme.spacing.lg} 0;
  overflow: visible;
`;

const JournalEntryRow = styled.tr`
  &:nth-child(even) {
    background: ${({ theme }) => theme.colors.background};
  }
`;

const AmountInput = styled.input`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.sm};
  text-align: right;

  &:focus {
    outline: none;
    border-color: ${({ theme }) => theme.colors.primary};
  }
`;

const TotalRow = styled.tr`
  font-weight: 700;
  background: ${({ theme }) => theme.colors.background};
  border-top: 2px solid ${({ theme }) => theme.colors.border};
`;

const BalanceIndicator = styled.span<{ balanced: boolean }>`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  color: ${({ balanced, theme }) => balanced ? theme.colors.secondary : theme.colors.accent};
  font-weight: 600;
`;

const StatsGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const StatCard = styled.div`
  background: ${({ theme }) => theme.colors.surface};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.lg};
  padding: ${({ theme }) => theme.spacing.lg};
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
`;

const StatIcon = styled.div<{ color: string }>`
  width: 48px;
  height: 48px;
  border-radius: ${({ theme }) => theme.borderRadius.md};
  background: ${({ color }) => `${color}15`};
  color: ${({ color }) => color};
  display: flex;
  align-items: center;
  justify-content: center;
`;

const StatContent = styled.div`
  flex: 1;
`;

const StatValue = styled.div`
  font-size: 1.5rem;
  font-weight: 700;
  color: ${({ theme }) => theme.colors.text.primary};
`;

const StatLabel = styled.div`
  font-size: 0.875rem;
  color: ${({ theme }) => theme.colors.text.secondary};
`;

const IconButton = styled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.md};
  background-color: ${({ theme }) => theme.colors.surface};
  color: ${({ theme }) => theme.colors.text.secondary};
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background-color: ${({ theme }) => theme.colors.background};
    border-color: ${({ theme }) => theme.colors.primary};
    color: ${({ theme }) => theme.colors.primary};
    transform: translateY(-1px);
  }

  &:active {
    transform: translateY(0);
  }
`;

const Bookkeeping: React.FC = () => {
  // Get shared data from context
  const {
    journalEntries,
    addJournalEntry,
    updateJournalEntry,
    deleteJournalEntry,
    postJournalEntry,
    voidJournalEntry,
    accounts: contextAccounts,
    transactions
  } = useData();

  const [activeTab, setActiveTab] = useState('journal');
  const [showJournalModal, setShowJournalModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [selectedTransaction, setSelectedTransaction] = useState<Transaction | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [loading, setLoading] = useState(true);
  const [expandedCategories, setExpandedCategories] = useState<{ [key: string]: boolean }>({
    'ASSETS': true,
    'LIABILITIES': true,
    'EQUITY': true,
    'REVENUE': true,
    'COST OF GOODS SOLD': true,
    'OPERATING EXPENSES': true
  });

  // Convert context accounts to local format with uppercase types
  const accounts = contextAccounts.map((acc, index) => ({
    id: index + 1,
    account_code: acc.code,
    account_name: acc.name,
    account_type: acc.type === 'Asset' ? 'ASSETS' :
                  acc.type === 'Liability' ? 'LIABILITIES' :
                  acc.type === 'Equity' ? 'EQUITY' :
                  acc.type === 'Revenue' ? 'REVENUE' :
                  acc.type === 'Expense' ? 'OPERATING EXPENSES' : acc.type,
    subcategory: acc.subcategory,
    balance: acc.balance || 0
  }));

  // Journal Entry State
  const [journalEntry, setJournalEntry] = useState<JournalEntry>({
    date: new Date().toISOString().split('T')[0],
    description: '',
    reference: '',
    lines: [
      { account_id: 0, debit_amount: 0, credit_amount: 0, description: '' },
      { account_id: 0, debit_amount: 0, credit_amount: 0, description: '' }
    ]
  });

  // Load initial data - now using shared context, just set loading to false
  useEffect(() => {
    setLoading(false);
  }, []);

  /* COMMENTED OUT - Now using shared DataContext
  const loadAccounts = async () => {
    try {
      // Parse Chart of Accounts JSON data
      const coaData = chartOfAccountsData.chartOfAccounts as any;
      const parsedAccounts: Account[] = [];
      let idCounter = 1;

      // Iterate through all account groups
      Object.entries(coaData).forEach(([groupCode, groupData]: [string, any]) => {
        const category = groupData.category;
        const subcategory = groupData.subcategory;
        const accounts = groupData.accounts;

        // Parse each account in the group
        Object.entries(accounts).forEach(([accountCode, accountDetails]: [string, any]) => {
          parsedAccounts.push({
            id: idCounter++,
            account_code: accountCode,
            account_name: accountDetails.name,
            account_type: category,
            subcategory: subcategory,
            balance: 0 // Initial balance, would be loaded from database
          });
        });
      });

      setAccounts(parsedAccounts);
    } catch (error) {
      console.error('Failed to load accounts:', error);
    } finally {
      setLoading(false);
    }
  };

  const loadTransactions = async () => {
    try {
      // Simulate API call - replace with actual API
      const mockTransactions: Transaction[] = [
        {
          id: 1,
          transaction_date: '2024-01-15',
          description: 'Johnson Residence - Shingle Installation',
          reference: 'JE-001',
          total_amount: 15000,
          transaction_type: 'Journal Entry'
        },
        {
          id: 2,
          transaction_date: '2024-01-20',
          description: 'Material Purchase - ABC Supply',
          reference: 'JE-002',
          total_amount: 5500,
          transaction_type: 'Journal Entry'
        },
        {
          id: 3,
          transaction_date: '2024-01-25',
          description: 'Labor Payment - Week 3',
          reference: 'JE-003',
          total_amount: 3200,
          transaction_type: 'Journal Entry'
        }
      ];
      setTransactions(mockTransactions);
    } catch (error) {
      console.error('Failed to load transactions:', error);
    }
  };
  *

  const addJournalLine = () => {
    setJournalEntry(prev => ({
      ...prev,
      lines: [...prev.lines, { account_id: 0, debit_amount: 0, credit_amount: 0, description: '' }]
    }));
  };

  const removeJournalLine = (index: number) => {
    if (journalEntry.lines.length > 2) {
      setJournalEntry(prev => ({
        ...prev,
        lines: prev.lines.filter((_, i) => i !== index)
      }));
    }
  };

  const updateJournalLine = (index: number, field: string, value: any) => {
    setJournalEntry(prev => ({
      ...prev,
      lines: prev.lines.map((line, i) =>
        i === index ? { ...line, [field]: value } : line
      )
    }));
  };

  const calculateTotals = () => {
    const totalDebits = journalEntry.lines.reduce((sum, line) => sum + (line.debit_amount || 0), 0);
    const totalCredits = journalEntry.lines.reduce((sum, line) => sum + (line.credit_amount || 0), 0);
    return { totalDebits, totalCredits, balanced: Math.abs(totalDebits - totalCredits) < 0.01 };
  };

  const toggleCategory = (category: string) => {
    setExpandedCategories(prev => ({
      ...prev,
      [category]: !prev[category]
    }));
  };

  const saveJournalEntry = async () => {
    const { balanced } = calculateTotals();
    if (!balanced) {
      alert('Journal entry must be balanced (total debits = total credits)');
      return;
    }

    try {
      // Simulate API call to save journal entry
      console.log('Saving journal entry:', journalEntry);

      // Reset form
      setJournalEntry({
        date: new Date().toISOString().split('T')[0],
        description: '',
        reference: '',
        lines: [
          { account_id: 0, debit_amount: 0, credit_amount: 0, description: '' },
          { account_id: 0, debit_amount: 0, credit_amount: 0, description: '' }
        ]
      });

      setShowJournalModal(false);
      loadTransactions(); // Reload to show new transaction
    } catch (error) {
      console.error('Failed to save journal entry:', error);
    }
  };

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(Math.abs(amount));
  };

  // Export Data functionality
  const handleExportData = () => {
    const currentDate = new Date().toISOString().split('T')[0];

    if (activeTab === 'journal') {
      // Export journal entries as CSV
      const headers = ['Date', 'Reference', 'Description', 'Type', 'Amount'];
      const csvContent = [
        headers.join(','),
        ...transactions.map(t => [
          new Date(t.transaction_date).toLocaleDateString(),
          t.reference,
          `"${t.description}"`,
          t.transaction_type,
          t.total_amount.toFixed(2)
        ].join(','))
      ].join('\\n');

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `FFR-Journal-Entries-${currentDate}.csv`;
      link.click();
      URL.revokeObjectURL(url);
    } else if (activeTab === 'ledger') {
      // Export chart of accounts as CSV
      const headers = ['Account Code', 'Account Name', 'Account Type', 'Balance'];
      const csvContent = [
        headers.join(','),
        ...accounts.map(acc => [
          acc.account_code,
          `"${acc.account_name}"`,
          acc.account_type,
          (acc.balance || 0).toFixed(2)
        ].join(','))
      ].join('\\n');

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `FFR-Chart-of-Accounts-${currentDate}.csv`;
      link.click();
      URL.revokeObjectURL(url);
    } else if (activeTab === 'trial') {
      // Export trial balance as CSV
      const headers = ['Account Code', 'Account Name', 'Debit', 'Credit'];
      const csvContent = [
        headers.join(','),
        ...accounts.map(acc => {
          const balance = acc.balance || 0;
          const isDebitBalance = ['Asset', 'Expense'].includes(acc.account_type) ? balance >= 0 : balance < 0;
          return [
            acc.account_code,
            `"${acc.account_name}"`,
            isDebitBalance ? Math.abs(balance).toFixed(2) : '0.00',
            !isDebitBalance ? Math.abs(balance).toFixed(2) : '0.00'
          ].join(',');
        })
      ].join('\\n');

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `FFR-Trial-Balance-${currentDate}.csv`;
      link.click();
      URL.revokeObjectURL(url);
    }
  };

  // Generate Report functionality
  const handleGenerateReport = async (printable: boolean = false) => {
    const jsPDF = (await import('jspdf')).default;
    const { addBrandedPDFHeader, addBrandedPDFFooter } = await import('../utils/PDFBrandedHeader');

    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const currentDate = new Date().toLocaleDateString();

    // Add branded FFR header with gradient and logo
    const contentStartY = await addBrandedPDFHeader(doc, {
      documentType: 'REPORT',
      showLogo: true,
      showContactInfo: true,
      printable
    });

    // Report title starts after header
    let currentY = contentStartY + 10;
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');

    if (activeTab === 'journal') {
      doc.text('Journal Entries Report', 20, currentY);
      currentY += 10;
      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.text(`Generated: ${currentDate}`, 20, currentY);
      currentY += 10;
      doc.text(`Total Transactions: ${transactions.length}`, 20, currentY);

      // Add transaction details
      currentY += 15;
      let yPos = currentY;
      doc.setFontSize(8);
      doc.text('Date', 20, yPos);
      doc.text('Reference', 50, yPos);
      doc.text('Description', 90, yPos);
      doc.text('Amount', 160, yPos);
      yPos += 10;

      transactions.slice(0, 25).forEach(transaction => {
        if (yPos > 270) {
          doc.addPage();
          yPos = 20;
        }
        doc.text(new Date(transaction.transaction_date).toLocaleDateString(), 20, yPos);
        doc.text(transaction.reference.substring(0, 15), 50, yPos);
        doc.text(transaction.description.substring(0, 25), 90, yPos);
        doc.text(`$${transaction.total_amount.toFixed(2)}`, 160, yPos);
        yPos += 8;
      });

    } else if (activeTab === 'trial') {
      doc.text('Trial Balance Report', 20, currentY);
      currentY += 10;
      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.text(`Generated: ${currentDate}`, 20, currentY);
      currentY += 10;

      const { totalDebits, totalCredits } = calculateTotals();
      doc.text(`Total Debits: $${totalDebits.toFixed(2)}`, 20, currentY);
      currentY += 10;
      doc.text(`Total Credits: $${totalCredits.toFixed(2)}`, 20, currentY);
      currentY += 10;
      doc.text(`Balanced: ${totalDebits === totalCredits ? 'Yes' : 'No'}`, 20, currentY);

      // Add account details
      currentY += 15;
      let yPos = currentY;
      doc.setFontSize(8);
      doc.text('Code', 20, yPos);
      doc.text('Account Name', 50, yPos);
      doc.text('Debit', 130, yPos);
      doc.text('Credit', 160, yPos);
      yPos += 10;

      accounts.forEach(account => {
        if (yPos > 270) {
          doc.addPage();
          yPos = 20;
        }
        const balance = account.balance || 0;
        const isDebitBalance = ['Asset', 'Expense'].includes(account.account_type) ? balance >= 0 : balance < 0;

        doc.text(account.account_code, 20, yPos);
        doc.text(account.account_name.substring(0, 30), 50, yPos);
        doc.text(isDebitBalance ? `$${Math.abs(balance).toFixed(2)}` : '-', 130, yPos);
        doc.text(!isDebitBalance ? `$${Math.abs(balance).toFixed(2)}` : '-', 160, yPos);
        yPos += 8;
      });
    }

    // Save the PDF
    const reportType = activeTab === 'journal' ? 'Journal-Entries' :
                     activeTab === 'trial' ? 'Trial-Balance' : 'Ledger';
    doc.save(`FFR-${reportType}-Report-${new Date().toISOString().split('T')[0]}.pdf`);
  };

  // Edit Transaction functionality
  const handleEditTransaction = (transaction: Transaction) => {
    setSelectedTransaction(transaction);
    setShowEditModal(true);
  };

  const handleSaveTransaction = () => {
    if (!selectedTransaction) return;

    // Update the transaction in the list
    setTransactions(transactions.map(t =>
      t.id === selectedTransaction.id ? selectedTransaction : t
    ));

    setShowEditModal(false);
    setSelectedTransaction(null);
  };

  const handleTransactionFieldChange = (field: keyof Transaction, value: any) => {
    if (!selectedTransaction) return;
    setSelectedTransaction({
      ...selectedTransaction,
      [field]: value
    });
  };

  // View Account Ledger functionality
  const handleViewAccountLedger = (account: Account) => {
    // Filter transactions for this account and show in a modal/page
    const accountTransactions = transactions.filter(t =>
      t.description.toLowerCase().includes(account.account_name.toLowerCase()) ||
      t.reference.toLowerCase().includes(account.account_code.toLowerCase())
    );

    const transactionSummary = accountTransactions.length > 0
      ? accountTransactions.map(t => `${new Date(t.transaction_date).toLocaleDateString()}: ${t.description} - $${t.total_amount.toFixed(2)}`).join('\\n')
      : 'No transactions found for this account.';

    alert(`Account Ledger: ${account.account_name} (${account.account_code})\\nBalance: $${(account.balance || 0).toFixed(2)}\\n\\nRecent Transactions:\\n${transactionSummary}\\n\\nThis would open a detailed ledger view in a full implementation.`);
  };

  const renderJournalEntries = () => {
    const filteredTransactions = transactions.filter(t =>
      t.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
      t.reference.toLowerCase().includes(searchTerm.toLowerCase())
    );

    return (
      <div>
        <ActionBar>
          <SearchContainer>
            <SearchInput
              placeholder="Search transactions..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
            <ActionButton>
              <Search size={16} />
            </ActionButton>
          </SearchContainer>
          <ActionButton variant="primary" onClick={() => setShowJournalModal(true)}>
            <Plus size={16} />
            New Journal Entry
          </ActionButton>
        </ActionBar>

        <TransactionTable>
          <thead>
            <tr>
              <TableHeader>Date</TableHeader>
              <TableHeader>Reference</TableHeader>
              <TableHeader>Description</TableHeader>
              <TableHeader>Type</TableHeader>
              <TableHeader>Amount</TableHeader>
              <TableHeader>Actions</TableHeader>
            </tr>
          </thead>
          <tbody>
            {filteredTransactions.map(transaction => (
              <TableRow key={transaction.id}>
                <TableCell>{new Date(transaction.transaction_date).toLocaleDateString()}</TableCell>
                <TableCell>{transaction.reference}</TableCell>
                <TableCell>{transaction.description}</TableCell>
                <TableCell>{transaction.transaction_type}</TableCell>
                <TableCell>{formatCurrency(transaction.total_amount)}</TableCell>
                <TableCell>
                  <IconButton onClick={() => handleEditTransaction(transaction)} title="Edit Transaction">
                    <Edit size={16} />
                  </IconButton>
                </TableCell>
              </TableRow>
            ))}
          </tbody>
        </TransactionTable>
      </div>
    );
  };

  const renderGeneralLedger = () => {
    // Get all unique category-subcategory combinations
    const categorySubcategoryGroups: { category: string; subcategory: string; accounts: Account[] }[] = [];
    const groupMap = new Map<string, Account[]>();

    accounts.forEach(account => {
      if (!account.subcategory) return;
      const key = `${account.account_type}|||${account.subcategory}`;
      if (!groupMap.has(key)) {
        groupMap.set(key, []);
      }
      groupMap.get(key)!.push(account);
    });

    // Convert to array and sort by category order
    const categoryOrder = ['ASSETS', 'LIABILITIES', 'EQUITY', 'REVENUE', 'COST OF GOODS SOLD', 'OPERATING EXPENSES'];
    groupMap.forEach((accounts, key) => {
      const [category, subcategory] = key.split('|||');
      categorySubcategoryGroups.push({ category, subcategory, accounts });
    });

    categorySubcategoryGroups.sort((a, b) => {
      const catCompare = categoryOrder.indexOf(a.category) - categoryOrder.indexOf(b.category);
      if (catCompare !== 0) return catCompare;
      return (a.subcategory || '').localeCompare(b.subcategory || '');
    });

    // Helper to render a subcategory group
    const renderSubcategoryGroup = (category: string, subcategory: string, groupAccounts: Account[]) => {
      // Apply search filter
      const filteredAccounts = groupAccounts.filter(account =>
        account.account_name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        account.account_code.toLowerCase().includes(searchTerm.toLowerCase())
      );

      if (filteredAccounts.length === 0) return null;

      const groupKey = `${category} - ${subcategory}`;
      const isExpanded = expandedCategories[groupKey] ?? true;

      return (
        <React.Fragment key={groupKey}>
          <CategoryHeaderRow
            expanded={isExpanded}
            onClick={() => toggleCategory(groupKey)}
          >
            <CategoryHeaderCell colSpan={5}>
              <CategoryIcon>
                {isExpanded ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
              </CategoryIcon>
              {groupKey}
              <span style={{ marginLeft: 'auto', fontSize: '0.875rem', fontWeight: 'normal' }}>
                {filteredAccounts.length} accounts
              </span>
            </CategoryHeaderCell>
          </CategoryHeaderRow>
          {isExpanded && filteredAccounts.map(account => (
            <TableRow key={account.id}>
              <TableCell style={{ paddingLeft: '2rem' }}>
                {account.account_code}
              </TableCell>
              <TableCell>{account.account_name}</TableCell>
              <TableCell>{account.account_type}</TableCell>
              <TableCell style={{
                color: (account.balance || 0) >= 0 ? '#059669' : '#dc2626',
                fontWeight: '600'
              }}>
                {formatCurrency(account.balance || 0)}
              </TableCell>
              <TableCell>
                <IconButton onClick={() => handleViewAccountLedger(account)} title="View Account Ledger">
                  <FileText size={16} />
                </IconButton>
              </TableCell>
            </TableRow>
          ))}
        </React.Fragment>
      );
    };

    return (
      <div>
        <ActionBar>
          <SearchContainer>
            <SearchInput
              placeholder="Search accounts..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
            <ActionButton>
              <Search size={16} />
            </ActionButton>
          </SearchContainer>
          <ActionButton>
            <Filter size={16} />
            Filter
          </ActionButton>
        </ActionBar>

        <TransactionTable>
          <thead>
            <tr>
              <TableHeader>Account Code</TableHeader>
              <TableHeader>Account Name</TableHeader>
              <TableHeader>Account Type</TableHeader>
              <TableHeader>Balance</TableHeader>
              <TableHeader>Actions</TableHeader>
            </tr>
          </thead>
          <tbody>
            {categorySubcategoryGroups.map(group =>
              renderSubcategoryGroup(group.category, group.subcategory, group.accounts)
            )}
          </tbody>
        </TransactionTable>
      </div>
    );
  };

  const renderTrialBalance = () => {
    const assetAccounts = accounts.filter(a => a.account_type === 'ASSETS');
    const liabilityAccounts = accounts.filter(a => a.account_type === 'LIABILITIES');
    const equityAccounts = accounts.filter(a => a.account_type === 'EQUITY');
    const revenueAccounts = accounts.filter(a => a.account_type === 'REVENUE');
    const cogsAccounts = accounts.filter(a => a.account_type === 'COST OF GOODS SOLD');
    const expenseAccounts = accounts.filter(a => a.account_type === 'OPERATING EXPENSES');

    const totalDebits = [...assetAccounts, ...cogsAccounts, ...expenseAccounts]
      .reduce((sum, account) => sum + Math.abs(account.balance || 0), 0);
    const totalCredits = [...liabilityAccounts, ...equityAccounts, ...revenueAccounts]
      .reduce((sum, account) => sum + Math.abs(account.balance || 0), 0);

    const isBalanced = Math.abs(totalDebits - totalCredits) < 0.01;

    // Get all unique category-subcategory combinations
    const categorySubcategoryGroups: { category: string; subcategory: string; accounts: Account[]; isDebitNormal: boolean }[] = [];
    const groupMap = new Map<string, { accounts: Account[]; isDebitNormal: boolean }>();

    const debitCategories = ['ASSETS', 'COST OF GOODS SOLD', 'OPERATING EXPENSES'];

    accounts.forEach(account => {
      if (!account.subcategory) return;
      const key = `${account.account_type}|||${account.subcategory}`;
      if (!groupMap.has(key)) {
        groupMap.set(key, { accounts: [], isDebitNormal: debitCategories.includes(account.account_type) });
      }
      groupMap.get(key)!.accounts.push(account);
    });

    // Convert to array and sort by category order
    const categoryOrder = ['ASSETS', 'LIABILITIES', 'EQUITY', 'REVENUE', 'COST OF GOODS SOLD', 'OPERATING EXPENSES'];
    groupMap.forEach((data, key) => {
      const [category, subcategory] = key.split('|||');
      categorySubcategoryGroups.push({ category, subcategory, accounts: data.accounts, isDebitNormal: data.isDebitNormal });
    });

    categorySubcategoryGroups.sort((a, b) => {
      const catCompare = categoryOrder.indexOf(a.category) - categoryOrder.indexOf(b.category);
      if (catCompare !== 0) return catCompare;
      return (a.subcategory || '').localeCompare(b.subcategory || '');
    });

    // Helper to render a subcategory group
    const renderSubcategoryGroup = (category: string, subcategory: string, groupAccounts: Account[], isDebitNormal: boolean) => {
      if (groupAccounts.length === 0) return null;

      const groupKey = `${category} - ${subcategory}`;
      const isExpanded = expandedCategories[groupKey] ?? true;

      return (
        <React.Fragment key={groupKey}>
          <CategoryHeaderRow
            expanded={isExpanded}
            onClick={() => toggleCategory(groupKey)}
          >
            <CategoryHeaderCell colSpan={4}>
              <CategoryIcon>
                {isExpanded ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
              </CategoryIcon>
              {groupKey}
              <span style={{ marginLeft: 'auto', fontSize: '0.875rem', fontWeight: 'normal' }}>
                {groupAccounts.length} accounts
              </span>
            </CategoryHeaderCell>
          </CategoryHeaderRow>
          {isExpanded && groupAccounts.map(account => {
            const balance = account.balance || 0;
            const showDebit = isDebitNormal;

            return (
              <TableRow key={account.id}>
                <TableCell style={{ paddingLeft: '2rem' }}>
                  {account.account_code}
                </TableCell>
                <TableCell>{account.account_name}</TableCell>
                <TableCell>
                  {showDebit ? formatCurrency(Math.abs(balance)) : '-'}
                </TableCell>
                <TableCell>
                  {!showDebit ? formatCurrency(Math.abs(balance)) : '-'}
                </TableCell>
              </TableRow>
            );
          })}
        </React.Fragment>
      );
    };

    return (
      <div>
        <StatsGrid>
          <StatCard>
            <StatIcon color="#059669">
              <DollarSign size={24} />
            </StatIcon>
            <StatContent>
              <StatValue>{formatCurrency(totalDebits)}</StatValue>
              <StatLabel>Total Debits</StatLabel>
            </StatContent>
          </StatCard>
          <StatCard>
            <StatIcon color="#dc2626">
              <DollarSign size={24} />
            </StatIcon>
            <StatContent>
              <StatValue>{formatCurrency(totalCredits)}</StatValue>
              <StatLabel>Total Credits</StatLabel>
            </StatContent>
          </StatCard>
          <StatCard>
            <StatIcon color={isBalanced ? "#059669" : "#dc2626"}>
              <Scale size={24} />
            </StatIcon>
            <StatContent>
              <StatValue>
                <BalanceIndicator balanced={isBalanced}>
                  {isBalanced ? <CheckCircle size={20} /> : <AlertCircle size={20} />}
                  {isBalanced ? 'Balanced' : 'Out of Balance'}
                </BalanceIndicator>
              </StatValue>
              <StatLabel>Trial Balance Status</StatLabel>
            </StatContent>
          </StatCard>
        </StatsGrid>

        <TransactionTable>
          <thead>
            <tr>
              <TableHeader>Account Code</TableHeader>
              <TableHeader>Account Name</TableHeader>
              <TableHeader>Debit Balance</TableHeader>
              <TableHeader>Credit Balance</TableHeader>
            </tr>
          </thead>
          <tbody>
            {categorySubcategoryGroups.map(group =>
              renderSubcategoryGroup(group.category, group.subcategory, group.accounts, group.isDebitNormal)
            )}

            <TotalRow>
              <TableCell colSpan={2}><strong>TOTALS</strong></TableCell>
              <TableCell><strong>{formatCurrency(totalDebits)}</strong></TableCell>
              <TableCell><strong>{formatCurrency(totalCredits)}</strong></TableCell>
            </TotalRow>
          </tbody>
        </TransactionTable>
      </div>
    );
  };

  const { totalDebits, totalCredits, balanced } = calculateTotals();

  if (loading) {
    return <div>Loading accounting data...</div>;
  }

  return (
    <BookkeepingContainer>
      <Header>
        <Title>
          <BookOpen size={28} />
          General Ledger & Bookkeeping
        </Title>
        <HeaderActions>
          <ActionButton variant="secondary" onClick={handleExportData}>
            <Download size={16} />
            Export Data
          </ActionButton>
          <ActionButton variant="secondary" onClick={() => handleGenerateReport(false)}>
            <BarChart3 size={16} />
            Generate Report
          </ActionButton>
        </HeaderActions>
      </Header>

      <TabContainer>
        <Tab active={activeTab === 'journal'} onClick={() => setActiveTab('journal')}>
          <FileText size={16} />
          Journal Entries
        </Tab>
        <Tab active={activeTab === 'ledger'} onClick={() => setActiveTab('ledger')}>
          <BookOpen size={16} />
          General Ledger
        </Tab>
        <Tab active={activeTab === 'trial'} onClick={() => setActiveTab('trial')}>
          <Scale size={16} />
          Trial Balance
        </Tab>
      </TabContainer>

      <ContentArea>
        {activeTab === 'journal' && renderJournalEntries()}
        {activeTab === 'ledger' && renderGeneralLedger()}
        {activeTab === 'trial' && renderTrialBalance()}
      </ContentArea>

      {/* Journal Entry Modal */}
      {showJournalModal && (
        <Modal
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          <ModalContent
            initial={{ scale: 0.9, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.9, opacity: 0 }}
          >
            <ModalHeader>
              <BrandedModalTitle>New Journal Entry</BrandedModalTitle>
              <IconButton onClick={() => setShowJournalModal(false)} title="Close">
                <X size={16} />
              </IconButton>
            </ModalHeader>

            <FormGrid>
              <FormGroup>
                <Label>Date</Label>
                <Input
                  type="date"
                  value={journalEntry.date}
                  onChange={(e) => setJournalEntry(prev => ({ ...prev, date: e.target.value }))}
                />
              </FormGroup>
              <FormGroup>
                <Label>Reference</Label>
                <Input
                  placeholder="JE-001"
                  value={journalEntry.reference}
                  onChange={(e) => setJournalEntry(prev => ({ ...prev, reference: e.target.value }))}
                />
              </FormGroup>
              <FormGroup style={{ gridColumn: '1 / -1' }}>
                <Label>Description</Label>
                <Input
                  placeholder="Journal entry description"
                  value={journalEntry.description}
                  onChange={(e) => setJournalEntry(prev => ({ ...prev, description: e.target.value }))}
                />
              </FormGroup>
            </FormGrid>

            <JournalEntryTable>
              <thead>
                <tr>
                  <TableHeader>Account</TableHeader>
                  <TableHeader>Description</TableHeader>
                  <TableHeader>Debit</TableHeader>
                  <TableHeader>Credit</TableHeader>
                  <TableHeader>Action</TableHeader>
                </tr>
              </thead>
              <tbody>
                {journalEntry.lines.map((line, index) => (
                  <JournalEntryRow key={index}>
                    <TableCell>
                      <Select
                        value={line.account_id}
                        onChange={(e) => updateJournalLine(index, 'account_id', parseInt(e.target.value))}
                      >
                        <option value={0}>Select Account</option>

                        {/* ASSETS with subcategories */}
                        {['Current Assets', 'Fixed Assets'].map(subcategory => {
                          const subAccounts = accounts.filter(a =>
                            a.account_type === 'ASSETS' && a.subcategory === subcategory
                          );
                          return subAccounts.length > 0 ? (
                            <optgroup key={subcategory} label={`═══ ${subcategory.toUpperCase()} ═══`}>
                              {subAccounts.map(account => (
                                <option key={account.id} value={account.id}>
                                  {account.account_code} - {account.account_name}
                                </option>
                              ))}
                            </optgroup>
                          ) : null;
                        })}

                        {/* LIABILITIES with subcategories */}
                        {['Current Liabilities', 'Long Term Liabilities'].map(subcategory => {
                          const subAccounts = accounts.filter(a =>
                            a.account_type === 'LIABILITIES' && a.subcategory === subcategory
                          );
                          return subAccounts.length > 0 ? (
                            <optgroup key={subcategory} label={`═══ ${subcategory.toUpperCase()} ═══`}>
                              {subAccounts.map(account => (
                                <option key={account.id} value={account.id}>
                                  {account.account_code} - {account.account_name}
                                </option>
                              ))}
                            </optgroup>
                          ) : null;
                        })}

                        {/* EQUITY */}
                        <optgroup label="═══ OWNER'S EQUITY ═══">
                          {accounts.filter(a => a.account_type === 'EQUITY').map(account => (
                            <option key={account.id} value={account.id}>
                              {account.account_code} - {account.account_name}
                            </option>
                          ))}
                        </optgroup>

                        {/* REVENUE */}
                        <optgroup label="═══ OPERATING REVENUE ═══">
                          {accounts.filter(a => a.account_type === 'REVENUE').map(account => (
                            <option key={account.id} value={account.id}>
                              {account.account_code} - {account.account_name}
                            </option>
                          ))}
                        </optgroup>

                        {/* COST OF GOODS SOLD */}
                        <optgroup label="═══ DIRECT JOB COSTS ═══">
                          {accounts.filter(a => a.account_type === 'COST OF GOODS SOLD').map(account => (
                            <option key={account.id} value={account.id}>
                              {account.account_code} - {account.account_name}
                            </option>
                          ))}
                        </optgroup>

                        {/* OPERATING EXPENSES */}
                        <optgroup label="═══ GENERAL & ADMINISTRATIVE ═══">
                          {accounts.filter(a => a.account_type === 'OPERATING EXPENSES').map(account => (
                            <option key={account.id} value={account.id}>
                              {account.account_code} - {account.account_name}
                            </option>
                          ))}
                        </optgroup>
                      </Select>
                    </TableCell>
                    <TableCell>
                      <Input
                        placeholder="Line description"
                        value={line.description}
                        onChange={(e) => updateJournalLine(index, 'description', e.target.value)}
                      />
                    </TableCell>
                    <TableCell>
                      <AmountInput
                        type="number"
                        step="0.01"
                        value={line.debit_amount || ''}
                        onChange={(e) => updateJournalLine(index, 'debit_amount', parseFloat(e.target.value) || 0)}
                      />
                    </TableCell>
                    <TableCell>
                      <AmountInput
                        type="number"
                        step="0.01"
                        value={line.credit_amount || ''}
                        onChange={(e) => updateJournalLine(index, 'credit_amount', parseFloat(e.target.value) || 0)}
                      />
                    </TableCell>
                    <TableCell>
                      <IconButton onClick={() => removeJournalLine(index)} title="Remove Line">
                        <X size={16} />
                      </IconButton>
                    </TableCell>
                  </JournalEntryRow>
                ))}
                <TotalRow>
                  <TableCell colSpan={2}>
                    <strong>TOTALS</strong>
                    <BalanceIndicator balanced={balanced}>
                      {balanced ? <CheckCircle size={16} /> : <AlertCircle size={16} />}
                      {balanced ? 'Balanced' : 'Out of Balance'}
                    </BalanceIndicator>
                  </TableCell>
                  <TableCell><strong>{formatCurrency(totalDebits)}</strong></TableCell>
                  <TableCell><strong>{formatCurrency(totalCredits)}</strong></TableCell>
                  <TableCell>
                    <IconButton onClick={addJournalLine} title="Add Line">
                      <Plus size={16} />
                    </IconButton>
                  </TableCell>
                </TotalRow>
              </tbody>
            </JournalEntryTable>

            <ActionBar>
              <div></div>
              <div style={{ display: 'flex', gap: '12px' }}>
                <ActionButton onClick={() => setShowJournalModal(false)}>
                  Cancel
                </ActionButton>
                <ActionButton variant="primary" onClick={saveJournalEntry} disabled={!balanced}>
                  <Save size={16} />
                  Save Journal Entry
                </ActionButton>
              </div>
            </ActionBar>
          </ModalContent>
        </Modal>
      )}

      {/* Edit Transaction Modal */}
      {showEditModal && selectedTransaction && (
        <Modal>
          <ModalContent>
            <ModalHeader>
              <BrandedModalTitle>Edit Transaction</BrandedModalTitle>
              <IconButton onClick={() => setShowEditModal(false)} title="Close">
                <X size={16} />
              </IconButton>
            </ModalHeader>

            <FormGrid>
              <FormGroup>
                <Label>Date</Label>
                <Input
                  type="date"
                  value={selectedTransaction.transaction_date}
                  onChange={(e) => handleTransactionFieldChange('transaction_date', e.target.value)}
                />
              </FormGroup>

              <FormGroup>
                <Label>Reference</Label>
                <Input
                  type="text"
                  value={selectedTransaction.reference}
                  onChange={(e) => handleTransactionFieldChange('reference', e.target.value)}
                />
              </FormGroup>

              <FormGroup style={{ gridColumn: '1 / -1' }}>
                <Label>Description</Label>
                <Input
                  type="text"
                  value={selectedTransaction.description}
                  onChange={(e) => handleTransactionFieldChange('description', e.target.value)}
                />
              </FormGroup>

              <FormGroup>
                <Label>Transaction Type</Label>
                <Select
                  value={selectedTransaction.transaction_type}
                  onChange={(e) => handleTransactionFieldChange('transaction_type', e.target.value)}
                >
                  <option value="Revenue">Revenue</option>
                  <option value="Expense">Expense</option>
                  <option value="Asset">Asset</option>
                  <option value="Liability">Liability</option>
                  <option value="Equity">Equity</option>
                </Select>
              </FormGroup>

              <FormGroup>
                <Label>Amount</Label>
                <Input
                  type="number"
                  step="0.01"
                  min="0"
                  value={selectedTransaction.total_amount}
                  onChange={(e) => handleTransactionFieldChange('total_amount', parseFloat(e.target.value) || 0)}
                />
              </FormGroup>
            </FormGrid>

            <ActionBar>
              <div></div>
              <div style={{ display: 'flex', gap: '12px' }}>
                <ActionButton onClick={() => setShowEditModal(false)}>
                  Cancel
                </ActionButton>
                <ActionButton variant="primary" onClick={handleSaveTransaction}>
                  <Save size={16} />
                  Save Changes
                </ActionButton>
              </div>
            </ActionBar>
          </ModalContent>
        </Modal>
      )}
    </BookkeepingContainer>
  );
};

export default Bookkeeping;